import openpyxl # Used for reading from the XLSX file
import json # Used to parse metadata for comment text
import os, platform # Used for opening the generated XLSX file
import sys # Used for exiting the program

# Output options
LOG_TABLE_NAMES = True
LOG_RECORDS = True
LOG_FIELDS = True

OPEN_FILE = True

INPUT_FILE = "datasets_complicated/sample.xlsx"
OUTPUT_FILE = "datasets_complicated/new.sql"

COMMENT_PREFIX = "AUTOGENERATED, DO NOT EDIT!\n" # Must be kept identical with COMMENT_PREFIX in the other script

# Logging functions
def log_table_name(text):
  if LOG_TABLE_NAMES: print(text)
def log_record(text):
  if LOG_RECORDS: print(text)
def log_field(text):
  if LOG_FIELDS: print(text)

# Load the XLSX file
workbook = openpyxl.load_workbook(INPUT_FILE)

# Create the SQL file object
with open(OUTPUT_FILE, 'w') as f:
  f.write("BEGIN TRANSACTION;\n")

  # For each worksheet, create the corresponding table in the SQL script
  for sheet in workbook.worksheets:
    table_name = sheet.title
    log_table_name(f"Extracting table: {table_name}")

    # Collect list of fields in this table
    fields = []
    field_metadata = []
    column = 1
    cell = sheet.cell(row=1, column=column)
    while cell.value:
      field_name = cell.value
      fields.append(field_name)

      # Extract field metadata
      comment_text = cell.comment.text
      prefix = comment_text[:len(COMMENT_PREFIX)]
      suffix = comment_text[len(COMMENT_PREFIX):]

      if prefix != COMMENT_PREFIX:
        log_field(f"ERROR: Comment verification failed: '{comment_text}'")
        sys.exit(1)

      metadata = json.loads(suffix)
      field_metadata.append(metadata)

      column += 1
      cell = sheet.cell(row=1, column=column)
      log_field(f"Detected field: {field_name} with metadata {metadata}")
    log_field(f"Detected {len(fields)} fields. The final, empty cell's value's type was: {str(type(cell.value))}")

    # Create the table
    f.write(f'CREATE TABLE "{table_name}" (\n')

    primary_key_field = None

    # Add the fields
    for column, field_name in enumerate(fields):
      metadata = field_metadata[column]
      if metadata["pk"]:
        if primary_key_field is not None:
          print("ERROR: duplicate primary key field specified!")
          sys.exit(1)
        primary_key_field = field_name

      # Primary key field doesn't get quotes around its name
      if primary_key_field == field_name:
        f.write(f'  {field_name}')
      else:
        f.write(f'  "{field_name}"')

      f.write(f' {metadata["type"]}')
      if metadata["not_null"]: f.write(" NOT NULL")
      f.write(",\n")

    # Add the primary key
    if primary_key_field is not None:
      f.write(f'  PRIMARY KEY ({primary_key_field})\n')
    else:
      print("ERROR: no primary key field specified!")
      sys.exit(1)

    # End the table with close-paren
    f.write(");\n")

    # Insert records into the table
    for row_index, row_obj in enumerate(sheet.rows):
      if row_index == 0: continue # Skip the header row
      values = []
      for column_index, field in enumerate(fields):
        value = sheet.cell(row=row_index+1, column=column_index+1).value # Remember, 1-based indexing!
        # CCI uses an empty string to indicate NULL, but OpenPyXL uses None
        if value is None: value = ''
        value = str(value) # Ensure the value is a string, since Excel likes to auto-format booleans and numbers

        values.append(value)

      f.write(f'INSERT INTO "{table_name}" VALUES(')
      for column, value in enumerate(values):
        if column > 0: f.write(",")
        if isinstance(value, str): f.write(f"'{value}'")
        else: f.write(f"{value}")
      f.write(");\n")

  # End the file
  f.write("COMMIT;\n")

# Open the created SQL file
if OPEN_FILE:
  if platform.system() == "Windows":
    os.startfile(OUTPUT_FILE)
  else:
    os.system(f"open {OUTPUT_FILE}")