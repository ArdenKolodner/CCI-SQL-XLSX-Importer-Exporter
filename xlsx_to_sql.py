import argparse
import openpyxl # Used for reading from the XLSX file
import json # Used to parse metadata for comment text
import os, platform # Used for opening the generated XLSX file
import sys # Used for exiting the program

# Parse command line arguments
parser = argparse.ArgumentParser()
parser.add_argument("-i", "--input", help="Path to the XLSX script to convert", default="./generated.xlsx")
parser.add_argument("-o", "--output", help="Path to the SQL file to create", default="./datasets/sample.sql")

parser.add_argument("-ltn", "--log-table-names", help="Log names of detected tables", action="store_true")
parser.add_argument("-lr", "--log-records", help="Log detected records", action="store_true")
parser.add_argument("-lf", "--log-fields", help="Log names of detected fields in tables", action="store_true")

output_options = parser.add_argument_group("Output options")
output_options.add_argument("-of", "--open-file", help="Automatically open the generated SQL file", action="store_true")
output_options.add_argument("-nof", "--no-open-file", help="Do not open the generated SQL file", action="store_false", dest='open_file')
# By default, don't open the file at the end: assume the user will manually do that when using the file in CCI
parser.set_defaults(open_file=False)

args = parser.parse_args()

# Output options
LOG_TABLE_NAMES = args.log_table_names
LOG_RECORDS = args.log_records
LOG_FIELDS = args.log_fields

OPEN_FILE = args.open_file

INPUT_FILE = args.input
OUTPUT_FILE = args.output

COMMENT_PREFIX = "AUTOGENERATED, DO NOT EDIT!\n" # Must be kept identical with COMMENT_PREFIX in the other script
DEFAULT_METADATA = {"type": "VARCHAR(255)", "not_null": False, "pk": 0} # Used for fields with no comment, assumed to be added by the user in Excel

# Logging functions
def log_table_name(text):
  if LOG_TABLE_NAMES: print(text)
def log_record(text):
  if LOG_RECORDS: print(text)
def log_field(text):
  if LOG_FIELDS: print(text)

# Load the XLSX file
workbook = openpyxl.load_workbook(INPUT_FILE)

# Create the SQL file object
with open(OUTPUT_FILE, 'w') as f:
  f.write("BEGIN TRANSACTION;\n")

  # For each worksheet, create the corresponding table in the SQL script
  for sheet in workbook.worksheets:
    table_name = sheet.title
    log_table_name(f"Extracting table: {table_name}")

    # Collect list of fields in this table
    fields = []
    field_metadata = []
    column = 1
    cell = sheet.cell(row=1, column=column)
    while cell.value:
      field_name = cell.value
      fields.append(field_name)

      # Extract field metadata
      if cell.comment:
        comment_text = cell.comment.text
        prefix = comment_text[:len(COMMENT_PREFIX)]
        suffix = comment_text[len(COMMENT_PREFIX):]

        if prefix != COMMENT_PREFIX:
          log_field(f"ERROR: Comment verification failed: '{comment_text}'")
          sys.exit(1)

        metadata = json.loads(suffix)
        field_metadata.append(metadata)
      else:
        log_field(f"WARNING: No comment found for field {field_name}. Using default type: VARCHAR(255), not primary key.")
        metadata = DEFAULT_METADATA
        field_metadata.append(metadata)

      column += 1
      cell = sheet.cell(row=1, column=column)
      log_field(f"Detected field: {field_name} with metadata {metadata}")
    log_field(f"Detected {len(fields)} fields. The final, empty cell's value's type was: {str(type(cell.value))}")

    # Create the table
    f.write(f'CREATE TABLE "{table_name}" (\n')

    primary_key_field = None

    # Add the fields
    for column, field_name in enumerate(fields):
      metadata = field_metadata[column]
      if metadata["pk"]:
        if primary_key_field is not None:
          print(f"ERROR: table {table_name}: duplicate primary key field specified!")
          sys.exit(1)
        primary_key_field = field_name

      # Primary key field doesn't get quotes around its name
      if primary_key_field == field_name:
        f.write(f'  {field_name}')
      else:
        f.write(f'  "{field_name}"')

      f.write(f' {metadata["type"]}')
      if metadata["not_null"]: f.write(" NOT NULL")
      f.write(",\n")

    # Add the primary key
    if primary_key_field is not None:
      f.write(f'  PRIMARY KEY ({primary_key_field})\n')
    else:
      print("ERROR: table {table_name}: no primary key field specified!")
      sys.exit(1)

    # End the table with close-paren
    f.write(");\n")

    # Insert records into the table
    for row_index, row_obj in enumerate(sheet.rows):
      if row_index == 0: continue # Skip the header row

      # Skip empty rows
      if not any(cell.value for cell in row_obj):
        continue

      values = []
      for column_index, field in enumerate(fields):
        value = sheet.cell(row=row_index+1, column=column_index+1).value # Remember, 1-based indexing!
        # CCI uses an empty string to indicate NULL, but OpenPyXL uses None
        if value is None: value = ''
        value = str(value) # Ensure the value is a string, since Excel likes to auto-format booleans and numbers

        values.append(value)

      f.write(f'INSERT INTO "{table_name}" VALUES(')
      for column, value in enumerate(values):
        if column > 0: f.write(",")
        if isinstance(value, str): f.write(f"'{value}'")
        else: f.write(f"{value}")
      f.write(");\n")

      log_record(f"Record in table {table_name}: {values}")

  # End the file
  f.write("COMMIT;\n")

# Open the created SQL file
if OPEN_FILE:
  if platform.system() == "Windows":
    os.startfile(OUTPUT_FILE)
  else:
    os.system(f"open {OUTPUT_FILE}")